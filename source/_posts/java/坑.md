---
title: 【java】那些踩过的坑
date: 2019-09-24 20:00:13
toc: true
comments: true
tags:
  - java
---

## mybatis 语句拼接问题

```java
/**
* 从 provider_marketable_goods 表中删除数据
*
* @param providerIds 拼接的 providerId
*/
@Update("<script>" +
        "delete from goods where provider_id in (#{providerIds})" +
        "</script>")
void removeGoodsByProviderId(@Param("providerIds") String providerIds);
```

实际的运行 sql 语句是： delete from goods where provider_id in ('23,432,4432,4432')

下面这个才是你想要的：

```java
/**
* 从 provider_marketable_goods 表中删除数据
*
* @param providerIds 拼接的 providerId
*/
@Update("<script>" +
        "delete from goods where provider_id in (" +
        "<foreach collection='providerIds' item='providerId' separator=','>" +
        "#{providerId}" +
        "</foreach>" +
        ")" +
        "</script>")
void removeGoodsByProviderId(@Param("providerIds") Set<Long> providerIds);
```

实际的运行 sql 语句是： delete from goods where provider_id in (23,432,4432,4432)

## 作用域问题

搞错作用域，会导致获取的数据莫名其妙。
例如下面，本该放在循环内的，结果放在了循环之内（这种 bug 比较难找，要小心才是）。

```java
private void divideToHandleProviderIdToGoodsIdListMap(Consumer<Map<Long, List<Integer>>> consumer) {

    Map<Long, List<Integer>> map = Maps.newHashMap(); // outside the loop
    final int number = 100;
    int count = 0;
    List<ProviderGoods> list;
    do {
        list = providerMarketableDao.getProviderGoodsFromGoods(count * number, number);
        list.stream().collect(Collectors.groupingBy(ProviderGoods::getProviderId))
                .forEach((providerId, providerGoodsList) -> {
                    map.put(providerId, providerGoodsList.stream()
                            .map(ProviderGoods::getGoodsId)
                            .collect(Collectors.toList()));
                });
        consumer.accept(map);
        count++;
    } while (isNotEmptyList(list));
}
```

```java
private void divideToHandleProviderIdToGoodsIdListMap(Consumer<Map<Long, List<Integer>>> consumer) {

    final int number = 100;
    int count = 0;
    List<ProviderGoods> list;
    do {
        Map<Long, List<Integer>> map = Maps.newHashMap(); // within the loop
        list = providerMarketableDao.getProviderGoodsFromGoods(count * number, number);
        list.stream().collect(Collectors.groupingBy(ProviderGoods::getProviderId))
                .forEach((providerId, providerGoodsList) -> {
                    map.put(providerId, providerGoodsList.stream()
                            .map(ProviderGoods::getGoodsId)
                            .collect(Collectors.toList()));
                });
        consumer.accept(map);
        count++;
    } while (isNotEmptyList(list));
}
```
