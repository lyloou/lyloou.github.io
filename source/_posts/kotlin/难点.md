---
title: Kotlin疑点难点
date: 2019-06-04 10:46:03
toc: true
comments: true
tags:
  - kotlin
---

## with

本书中我们大量讲了这个函数。 with 接收一个对象和一个函数，这个函数会作为
这个对象的扩展函数执行。这表示我们根据推断可以在函数内使用 this 。

```
inline fun <T, R> with(receiver: T, f: T.() -> R): R = receiver.f()
```

泛型在这里也是以相同的方式运行： T 代表接收类型， R 代表结果。如你所见，
函数通过 f: T.() -> R 声明被定义成了**扩展函数**。这就是为什么我们可以调
用 receiver.f() 。
kotlin-for-android-developers-zh p188

## 构造器

> 下面 3 种声明都是等效的 （《kotlin 实战》p81）

**实现 1**

```kt
class User constructor(_nickname:String){
    val nickname: String
    init {
        nickname = _nickname
    }
}
```

**实现 2**

```kt
class User(_nickname:String){
    val nickname = _nickname // 如果主构造方法没有注解和可见性修饰符，可以去掉 `constructor` 关键字；也不用放到 init 中，可以在声明的时候初始化了
}
```

**实现 3**

```kt
class User(val nickname: String) // “val” 意味着相应的属性会用构造方法的参数来初始化
```
