---
title: 【算法】顺时针打印矩阵
date: 2022-01-21 17:05:58
toc: true
comments: true
tags:
  - 算法
---

## 剑指 Offer 第 23 题-链表中环的入口结点

描述: 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下 4 X 4 矩阵：

```
[[1,2,3,4],
[5,6,7,8],
[9,10,11,12],
[13,14,15,16]]
```

则依次打印出数字

[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]

数据范围:

0 <= matrix.length <= 100

0 <= matrix[i].length <= 100

例如：

![jz29-顺时针打印矩阵_20220121170748_2022-01-21-17-07-49](https://raw.githubusercontent.com/lyloou/img/develop/jz29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5_20220121170748_2022-01-21-17-07-49.png)

## 方法 1

```java
public class Jz29_2 {
    public static void main(String[] args) {
        final Jz29_2 jz = new Jz29_2();
        System.out.println(jz.printMatrix(new int[][]{
                {1, 2, 3, 1},
                {4, 5, 6, 1},
                {4, 5, 6, 1},
        }));

        System.out.println(jz.printMatrix(new int[][]{
                {1}, {2}, {3}, {4}, {5}
        }));

        System.out.println(jz.printMatrix(new int[][]{
                {1, 2, 3, 4, 5}
        }));

        System.out.println(jz.printMatrix(new int[][]{
                {1, 2, 3, 4},
                {5, 6, 7, 8},
                {9, 10, 11, 12},
                {13, 14, 15, 16}
        }));
    }

    public ArrayList<Integer> printMatrix(int[][] matrix) {
        // 为空的情况
        if (matrix == null || matrix.length == 0) {
            return new ArrayList<>();
        }

        ArrayList<Integer> list = new ArrayList<>(matrix.length * matrix[0].length);
        int minI = 0;
        int minJ = 0;
        int maxI = matrix.length - 1;
        int maxJ = matrix[0].length - 1;
        int i, j;

        while (minI <= maxI && minJ <= maxJ) {
            // 用两个标识来判断本轮是否有下移或左移
            boolean down = false;
            boolean left = false;

            // 从左上角开始
            // 右移
            for (i = minI, j = minJ; j <= maxJ; j++) {
                list.add(matrix[i][j]);
            }

            // 下移
            for (i = minI + 1, j = maxJ; i <= maxI; i++) {
                list.add(matrix[i][j]);
                down = true;
            }

            // 左移，左移之前确认是否有下移，防止重复
            for (i = maxI, j = maxJ - 1; down && j >= minI; j--) {
                list.add(matrix[i][j]);
                left = true;
            }

            // 上移，上移之前确认是否有左移，防止重复
            for (i = maxI - 1, j = minJ; left && i > minI; i--) {
                list.add(matrix[i][j]);
            }

            // 缩小一圈
            minI++;
            minJ++;
            maxJ--;
            maxI--;

        }

        return list;
    }
}

```
