---
title: 网络请求巧用
date: 2020-03-26 16:09:18
toc: true
comments: true
tags:

- android

---

## 用到的库

- Retrofit
- RxJava2

```kotlin
def rxandroidVersion = '2.0.1'
implementation "io.reactivex.rxjava2:rxandroid:$rxandroidVersion"
def retrofitVersion = '2.8.0'
implementation "com.squareup.retrofit2:retrofit:$retrofitVersion"
implementation "com.squareup.retrofit2:adapter-rxjava2:$retrofitVersion"
implementation "com.squareup.retrofit2:converter-gson:$retrofitVersion"
implementation 'com.google.code.gson:gson:2.8.5'
```

## 服务器统一返回格式

当 `error_code` 不为 `0` 时，就不用解析 `data`（其值为 `null`），根据相应的错误码提示给用户；

```json
{
  "err_code": 1101,
  "err_msg": "参数name不能为空"
}
```

当 `error_code` 为 `0` 时，就可以解析 `data`，这个返回值通过实体类或列表来映射得到。

```json
{
  "err_code": 0,
  "err_msg": "ok",
  "data": {
    "id": 1,
    "name": "lyloou",
    "email": "lyloou@qq.com",
    "personal_signature": "多么美好的太阳",
    "gmt_create": "2020-01-16T09:38:18.000+0000",
    "gmt_modified": "2020-03-14T11:27:58.000+0000",
    "is_disabled": false
  }
}
```

## 定义返回类

通过 CResult 来接收返回的数据，`data` 的通过泛型来映射成对应实体类（用泛型的好处，是不用为每一个返回都建立一个类）；

```kotlin
// https://medium.com/@stustirling/responses-errors-with-retrofit-2-rxjava2-6d55eafecf5a
data class CResult<T>(var err_code: Int, var err_msg: String, var data: T?)

```

## Retrofit 简单封装

> 具体用法参考：[Retrofit 官网](https://square.github.io/retrofit/)

```kotlin
// Network.kt
val gson: Gson = GsonBuilder()
    .setDateFormat("yyyy-MM-dd HH:mm:ss")
    .setLenient()
    .create()
fun Any.toJsonString(): String {
    return gson.toJson(this)
}

object Network {
    private var headerPairs: (() -> List<Pair<String, String>>)? = null
    private val builder = Retrofit.Builder()
        .addConverterFactory(GsonConverterFactory.create(gson))
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create());

    fun withHeader(pairList: (() -> List<Pair<String, String>>)): Network {
        this.headerPairs = pairList
        return this
    }

    fun <T> get(baseUrl: String, clazz: Class<T>): T {
        val okHttpBuilder = OkHttpClient.Builder()
        headerPairs?.invoke()?.let {
            okHttpBuilder.addInterceptor(interceptor(it))
        }
        return builder.baseUrl(baseUrl)
            .client(okHttpBuilder.build())
            .build().create(clazz)
    }

    // 如果是需要授权才能获取信息，统一用这个。
    // 把用户信息和授权信息通过 header 的方式发到服务器
    // [Retrofit — Add Custom Request Header](https://futurestud.io/tutorials/retrofit-add-custom-request-header)
    fun auth(userPassword: UserPassword?): List<Pair<String, String>> {
        userPassword?.let {
            return listOf(
                "Content-Type" to "application/json",
                "Authorization" to it.password,
                "UserId" to it.userId.toString()
            )
        }
        return emptyList()
    }
}

fun interceptor(headers: List<Pair<String, String>>): (Interceptor.Chain) -> Response {
    return {
        val newBuilder = it.request().newBuilder()
        headers.forEach { header ->
            newBuilder.addHeader(header.first, header.second)
        }
        it.proceed(newBuilder.build())
    }
}

fun <T> Observable<T>.defaultScheduler(): Observable<T> {
    return this.subscribeOn(Schedulers.io())
        .unsubscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
}
```

## 准备用户的类和 retrofit 接口

```kotlin
// user.kt
data class User(
    val id: Long,
    val name: String,
    val email: String,
    @SerializedName("personal_signature")
    val personalSignature: String,
    @SerializedName("gmt_create")
    val gmtCreate: Date
)

data class UserPassword(
    val userId: Long,
    val name: String,
    val password: String
)

enum class Url(val url: String) : Str {
    UserApi("http://127.0.0.1:8888/api/v1/user/"),
    ;
}

interface UserApi {
    @POST("login")
    fun login(@Query("name") name: String, @Query("password") password: String): Observable<CResult<User?>>

    @POST("update")
    fun update(@Body user: User): Observable<CResult<String?>>
}


fun Network.userApi(): UserApi {
    return get(Url.UserApi.url, UserApi::class.java)
}

// 创建带授权的 userApi
fun Network.userWithAuthApi(userPassword: UserPassword? = UserPasswordHelper.getUserPassword()): UserApi {
    return withHeader { auth(userPassword) }
        .get(Url.UserApi.url, UserApi::class.java);
}

```

## 使用

```kotlin
// 用户登录
Network.userApi()
    .login(name, encodedPassword)
    .defaultScheduler()
    .subscribe({
        if (it.err_code == 0) {
            // save user info to localStorage
        } else {
            toast("错误代码:${it.err_code}，错误信息：${it.err_msg}")
        }
    }, {
        toast("网络异常：${it.message}")
    })

// 更新用户
Network.userApi()
    .update(user)
    .defaultScheduler()
    .subscribe({
        if (it.err_code == 0) {
            // doSuccess
        } else {
            // do error
        }
    }, {
        toast("网络异常：${it.message}")
    })
```

## 总结

结合使用 kotlin 的扩展功能，可以简化许多冗余的代码。
